"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Copilot_1 = require("./Copilot");
const StepPerformer_1 = require("./actions/StepPerformer");
const CopilotError_1 = require("./errors/CopilotError");
jest.mock('@/actions/StepPerformer');
describe('Copilot', () => {
    let mockConfig;
    beforeEach(() => {
        mockConfig = {
            frameworkDriver: {
                captureSnapshotImage: jest.fn(),
                captureViewHierarchyString: jest.fn(),
                apiCatalog: {
                    context: {},
                    categories: []
                },
            },
            promptHandler: {
                runPrompt: jest.fn(),
                isSnapshotImageSupported: jest.fn().mockReturnValue(true)
            }
        };
        jest.spyOn(console, 'error').mockImplementation(() => { });
        StepPerformer_1.StepPerformer.prototype.perform.mockResolvedValue({ code: 'code', result: true });
    });
    afterEach(() => {
        jest.resetAllMocks();
        console.error.mockRestore();
        Copilot_1.Copilot['instance'] = undefined;
    });
    describe('getInstance', () => {
        it('should return the same instance after initialization', () => {
            Copilot_1.Copilot.init(mockConfig);
            const instance1 = Copilot_1.Copilot.getInstance();
            const instance2 = Copilot_1.Copilot.getInstance();
            expect(instance1).toBe(instance2);
        });
        it('should throw CopilotError if getInstance is called before init', () => {
            expect(() => Copilot_1.Copilot.getInstance()).toThrow(CopilotError_1.CopilotError);
            expect(() => Copilot_1.Copilot.getInstance()).toThrow('Copilot has not been initialized. Please call the `init()` method before using it.');
        });
    });
    describe('init', () => {
        it('should create a new instance of Copilot', () => {
            Copilot_1.Copilot.init(mockConfig);
            expect(Copilot_1.Copilot.getInstance()).toBeInstanceOf(Copilot_1.Copilot);
        });
        it('should overwrite existing instance when called multiple times', () => {
            Copilot_1.Copilot.init(mockConfig);
            const instance1 = Copilot_1.Copilot.getInstance();
            Copilot_1.Copilot.init(mockConfig);
            const instance2 = Copilot_1.Copilot.getInstance();
            expect(instance1).not.toBe(instance2);
        });
        it('should throw an error if config is invalid', () => {
            const invalidConfig = {};
            expect(() => Copilot_1.Copilot.init(invalidConfig)).toThrow();
        });
    });
    describe('perform', () => {
        it('should call StepPerformer.perform with the given intent', async () => {
            Copilot_1.Copilot.init(mockConfig);
            const instance = Copilot_1.Copilot.getInstance();
            const intent = 'tap button';
            await instance.performStep(intent);
            expect(StepPerformer_1.StepPerformer.prototype.perform).toHaveBeenCalledWith(intent, []);
        });
        it('should return the result from StepPerformer.perform', async () => {
            Copilot_1.Copilot.init(mockConfig);
            const instance = Copilot_1.Copilot.getInstance();
            const intent = 'tap button';
            const result = await instance.performStep(intent);
            expect(result).toBe(true);
        });
        it('should accumulate previous intents', async () => {
            Copilot_1.Copilot.init(mockConfig);
            const instance = Copilot_1.Copilot.getInstance();
            const intent1 = 'tap button 1';
            const intent2 = 'tap button 2';
            await instance.performStep(intent1);
            await instance.performStep(intent2);
            expect(StepPerformer_1.StepPerformer.prototype.perform).toHaveBeenLastCalledWith(intent2, [{
                    step: intent1,
                    code: 'code',
                    result: true
                }]);
        });
    });
    describe('reset', () => {
        it('should clear previous intents', async () => {
            Copilot_1.Copilot.init(mockConfig);
            const instance = Copilot_1.Copilot.getInstance();
            const intent1 = 'tap button 1';
            const intent2 = 'tap button 2';
            await instance.performStep(intent1);
            instance.reset();
            await instance.performStep(intent2);
            expect(StepPerformer_1.StepPerformer.prototype.perform).toHaveBeenLastCalledWith(intent2, []);
        });
    });
});
