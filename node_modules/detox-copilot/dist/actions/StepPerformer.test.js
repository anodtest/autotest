"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const StepPerformer_1 = require("../actions/StepPerformer");
const fs = __importStar(require("fs"));
const crypto = __importStar(require("crypto"));
jest.mock('fs');
jest.mock('crypto');
describe('StepPerformer', () => {
    let stepPerformer;
    let mockContext;
    let mockPromptCreator;
    let mockCodeEvaluator;
    let mockSnapshotManager;
    let mockPromptHandler;
    const cacheFileName = 'test_step_performer_cache.json';
    beforeEach(() => {
        jest.resetAllMocks();
        // Mock fs methods to prevent actual file system interactions
        fs.existsSync.mockReturnValue(false);
        fs.readFileSync.mockReturnValue('');
        fs.writeFileSync.mockImplementation(() => { });
        const apiCatalog = {
            context: {},
            categories: [],
        };
        mockContext = {};
        // Create mock instances of dependencies
        mockPromptCreator = {
            apiCatalog: apiCatalog,
            createPrompt: jest.fn(),
            createBasePrompt: jest.fn(),
            createContext: jest.fn(),
            createAPIInfo: jest.fn(),
        };
        mockCodeEvaluator = {
            evaluate: jest.fn(),
        };
        mockSnapshotManager = {
            captureSnapshotImage: jest.fn(),
            captureViewHierarchyString: jest.fn(),
        };
        mockPromptHandler = {
            runPrompt: jest.fn(),
            isSnapshotImageSupported: jest.fn(),
        };
        stepPerformer = new StepPerformer_1.StepPerformer(mockContext, mockPromptCreator, mockCodeEvaluator, mockSnapshotManager, mockPromptHandler, cacheFileName);
    });
    const setupMocks = ({ isSnapshotSupported = true, snapshotData = 'snapshot_data', viewHierarchy = '<view></view>', promptResult = 'generated code', codeEvaluationResult = 'success', cacheExists = false, } = {}) => {
        mockPromptHandler.isSnapshotImageSupported.mockReturnValue(isSnapshotSupported);
        mockSnapshotManager.captureSnapshotImage.mockResolvedValue(snapshotData != null ? snapshotData : undefined);
        mockSnapshotManager.captureViewHierarchyString.mockResolvedValue(viewHierarchy);
        mockPromptCreator.createPrompt.mockReturnValue('generated prompt');
        mockPromptHandler.runPrompt.mockResolvedValue(promptResult);
        mockCodeEvaluator.evaluate.mockResolvedValue(codeEvaluationResult);
        const viewHierarchyHash = 'hash';
        crypto.createHash.mockReturnValue({
            update: jest.fn().mockReturnValue({
                digest: jest.fn().mockReturnValue(viewHierarchyHash),
            }),
        });
        // Adjust fs mocks based on cacheExists
        if (cacheExists) {
            fs.existsSync.mockReturnValue(true);
            const cacheData = {};
            const cacheKey = JSON.stringify({ step: 'tap button', previous: [], viewHierarchyHash });
            // @ts-ignore
            cacheData[cacheKey] = promptResult;
            fs.readFileSync.mockReturnValue(JSON.stringify(cacheData));
        }
        else {
            fs.existsSync.mockReturnValue(false);
        }
    };
    it('should perform an intent successfully with snapshot image support', async () => {
        const intent = 'tap button';
        setupMocks();
        const result = await stepPerformer.perform(intent);
        expect(result).toBe('success');
        expect(mockPromptCreator.createPrompt).toHaveBeenCalledWith(intent, '<view></view>', true, []);
        expect(mockPromptHandler.runPrompt).toHaveBeenCalledWith('generated prompt', 'snapshot_data');
        expect(mockCodeEvaluator.evaluate).toHaveBeenCalledWith('generated code', mockContext);
        expect(fs.writeFileSync).toHaveBeenCalled(); // Ensure cache is saved
    });
    it('should perform an intent successfully without snapshot image support', async () => {
        const intent = 'tap button';
        setupMocks({ isSnapshotSupported: false });
        const result = await stepPerformer.perform(intent);
        expect(result).toBe('success');
        expect(mockPromptCreator.createPrompt).toHaveBeenCalledWith(intent, '<view></view>', false, []);
        expect(mockPromptHandler.runPrompt).toHaveBeenCalledWith('generated prompt', undefined);
        expect(mockCodeEvaluator.evaluate).toHaveBeenCalledWith('generated code', mockContext);
        expect(fs.writeFileSync).toHaveBeenCalled();
    });
    it('should perform an intent with undefined snapshot', async () => {
        const intent = 'tap button';
        setupMocks({ snapshotData: null });
        const result = await stepPerformer.perform(intent);
        expect(result).toBe('success');
        expect(mockPromptCreator.createPrompt).toHaveBeenCalledWith(intent, '<view></view>', false, []);
        expect(mockPromptHandler.runPrompt).toHaveBeenCalledWith('generated prompt', undefined);
        expect(mockCodeEvaluator.evaluate).toHaveBeenCalledWith('generated code', mockContext);
        expect(fs.writeFileSync).toHaveBeenCalled();
    });
    it('should perform an intent successfully with previous intents', async () => {
        const intent = 'current intent';
        const previousIntents = [{
                step: 'previous intent',
                code: 'previous code',
                result: 'previous result',
            }];
        setupMocks();
        const result = await stepPerformer.perform(intent, previousIntents);
        expect(result).toBe('success');
        expect(mockPromptCreator.createPrompt).toHaveBeenCalledWith(intent, '<view></view>', true, previousIntents);
        expect(mockPromptHandler.runPrompt).toHaveBeenCalledWith('generated prompt', 'snapshot_data');
        expect(mockCodeEvaluator.evaluate).toHaveBeenCalledWith('generated code', mockContext);
        expect(fs.writeFileSync).toHaveBeenCalled();
    });
    it('should throw an error if code evaluation fails', async () => {
        const intent = 'tap button';
        setupMocks();
        mockCodeEvaluator.evaluate.mockRejectedValue(new Error('Evaluation failed'));
        await expect(stepPerformer.perform(intent)).rejects.toThrow('Evaluation failed');
        expect(fs.writeFileSync).not.toHaveBeenCalled(); // Cache should not be saved
    });
    it('should use cached prompt result if available', async () => {
        const intent = 'tap button';
        setupMocks({ cacheExists: true });
        const result = await stepPerformer.perform(intent);
        expect(result).toBe('success');
        // Should not call runPrompt or createPrompt since result is cached
        expect(mockPromptCreator.createPrompt).not.toHaveBeenCalled();
        expect(mockPromptHandler.runPrompt).not.toHaveBeenCalled();
        expect(mockCodeEvaluator.evaluate).toHaveBeenCalledWith('generated code', mockContext);
        expect(fs.writeFileSync).not.toHaveBeenCalled(); // No need to save cache again
    });
    it('should retry if initial runPrompt throws an error and succeed on retry', async () => {
        const intent = 'tap button';
        setupMocks();
        const error = new Error('Initial prompt failed');
        mockPromptHandler.runPrompt.mockRejectedValueOnce(error);
        // On retry, it succeeds
        mockPromptHandler.runPrompt.mockResolvedValueOnce('retry generated code');
        const result = await stepPerformer.perform(intent);
        expect(result).toBe('success');
        expect(mockPromptCreator.createPrompt).toHaveBeenCalledTimes(2);
        expect(mockPromptHandler.runPrompt).toHaveBeenCalledTimes(2);
        expect(mockCodeEvaluator.evaluate).toHaveBeenCalledWith('retry generated code', mockContext);
        expect(fs.writeFileSync).toHaveBeenCalledTimes(1); // Cache should be saved after success
    });
    it('should throw original error if retry also fails', async () => {
        const intent = 'tap button';
        setupMocks();
        const error = new Error('Initial prompt failed');
        const retryError = new Error('Retry prompt failed');
        mockPromptHandler.runPrompt.mockRejectedValueOnce(error);
        mockPromptHandler.runPrompt.mockRejectedValueOnce(retryError);
        await expect(stepPerformer.perform(intent)).rejects.toThrow(error);
        expect(mockPromptCreator.createPrompt).toHaveBeenCalledTimes(2);
        expect(mockPromptHandler.runPrompt).toHaveBeenCalledTimes(2);
        expect(mockCodeEvaluator.evaluate).not.toHaveBeenCalled();
        expect(fs.writeFileSync).not.toHaveBeenCalled();
    });
});
